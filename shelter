#!/usr/bin/env bash

. `dirname $0`/logger.sh

conf="build.conf"
dest=".cache"

# Function: Display help information
show_help() {
    cat <<EOF
Usage: shelter [Options] SubCommand
Available SubCommands:
    build   Build the shelter
    start   Start the shelter
    stop    Stop the shelter
    exec    exec a shell commad in shelter
    status  Query the status of shelter
    clean   Remove output image and cache

Options:
    -h, --help  Show this help message and exit
EOF
}

add_dir() {
    local dir_path=$1

    if [ ! -d ${dest}$dir_path ]; then
        mkdir -p ${dest}${dir_path}
    fi
}

copy_file_and_dir_no_resolve_symlink() {
    local src_path=$(realpath -s $1)
    local dst_path=${2:-$src_path}

    # Check if the path exists
    if [ ! -e "$src_path" ]; then
        error "Error: $src_path is not a valid file/dir path"
        exit 1
    fi

    # Check if is a file and already copied
    if ([ -e "${dest}${dst_path}" ] || [ -L "${dest}${dst_path}" ]) && ! diff -q "${src_path}" "${dest}${dst_path}" >/dev/null ; then
        warn "Warn: target path $dst_path already existed in $dest but different, will be overwrited"
    fi

    if [[ -d "$src_path" ]]; then
        src_path="$src_path"/
        dst_path="$dst_path"/
    fi

    rsync -ap --links ${src_path} ${dest}${dst_path}
}

# Function to copy file (dir is not handled)
copy_file_resolve_symlink() {
    local src_path=$(realpath -s $1)
    local dst_path=${2:-$src_path}

    # Check if the file exists
    if [ ! -e "$src_path" ]; then
        error "Error: $src_path is not a valid file path"
        exit 1
    fi

    # Check if the file already copied
    if [ -e "${dest}${dst_path}" ] && ! diff -q "${src_path}" "${dest}${dst_path}" >/dev/null ; then
        warn "Warn: target path $dst_path already existed in $dest but different, will be overwrited"
    fi

    # Check if file is symbolic link
    if [ -L "$src_path" ]; then
        local target_file_path=$(realpath $1)
        copy_file_resolve_symlink $target_file_path
        add_dir $(dirname $dst_path)
        rsync -a --links ${src_path} ${dest}${dst_path}
        return
    fi

    # Check if file is regular
    if [ -f "$src_path" ]; then
        add_dir $(dirname $dst_path)
        cp -a ${src_path} ${dest}${dst_path}
        return
    fi

    warn "$src_path isn't sysmlink or regular file"
    exit 1
}

# Function to copy shared library
copy_sodeps() {
    local binary_path=$1

    # Check if the file exists
    if [ ! -f "$binary_path" ]; then
        error "Error: $binary_path is not a valid file path"
        exit 1
    fi

    # Use ldd to get dependencies
    local dependencies=$(ldd "$binary_path" 2>/dev/null)

    if [ $? -ne 0 ]; then
        warn "Warn: $binary_path is not a dynamic binary"
        return 0
    fi

    # Parse ldd output and extract and copy dependency paths
    echo "$dependencies" | while read -r line; do
        # Check if the line not contains '=>'
        if ! echo "$line" | grep -q '=>'; then
            # Extract the path, ensuring it starts with /
            local lib_path
            lib_path=$(echo "$line" | awk '{print $1}' | grep '^/')
            if [ -n "$lib_path" ]; then
                copy_file_resolve_symlink "$lib_path"
                continue
            fi
        else
            local lib_path
            lib_path=$(echo "$line" | awk -F '=>' '{print $2}' | awk '{print $1}')
            if [ -n "$lib_path" ] && [ -e "$lib_path" ]; then
                copy_file_resolve_symlink "$lib_path"
            fi
        fi
    done
}

build() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c|--config)
                if [[ ! -z "$2" && "$2" != -* ]]; then
                    conf="$2"
                    shift
                else
                    error "Error: --config requires a value." >&2
                    return 1
                fi
                ;;
            *)
                error "Unrecognized option $1"
                return 1
                ;;
        esac
        shift
    done

    if [ ! -f $conf ]; then
        error "Error: build.conf didn't exist"
        exit 0
    fi

    local binaries=()
    local files=()

    info "Using $conf as config file"
    debug "Gather files to be copied to initrd and copy into $dest"
    rm -rf $dest

    # Read options from the configuration file
    while IFS= read -r line || [ -n "$line" ]; do
        # Trim leading and trailing whitespaces
        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        # Check line content and extract values
        if [[ $line == binary=* ]]; then
            # Remove binary= and parentheses
            line=$(echo "$line" | sed 's/^binary=//;s/[()]//g')
            # Split into an array and add to binaries array
            IFS=' ' read -r -a binary_array <<< "$line"
            binaries+=("${binary_array[@]}")
        elif [[ $line == file=* ]]; then
            # Remove file= and parentheses
            line=$(echo "$line" | sed 's/^file=//;s/[()]//g')
            # Split into an array and add to files array
            IFS=' ' read -r -a file_array <<< "$line"
            files+=("${file_array[@]}")
        fi
    done < "$conf"

    if [ ! -d $dest ]; then
        mkdir $dest
    fi

    # Assume any relative path in the source is always based on the directory
    # where the config file resides.
    local conf_dir=`dirname $conf`

    # Parse the mapping between the source and destinaion
    for i in "${binaries[@]}"; do
        if [[ "$i" == *:* ]]; then
            IFS=':' read -r src dst <<< "$i"
        else
            src="$i"
            dst="$i"
        fi

        # Prepend the prefix
        if [[ ! $src =~ ^/ ]]; then
            src="$conf_dir/$src"
        fi

        src="$(realpath $src)"

        copy_sodeps $src
        copy_file_resolve_symlink "$src" "$dst"
    done

    for i in "${files[@]}"; do
        if [[ "$i" == *:* ]]; then
            IFS=':' read -r src dst <<< "$i"
        else
            src="$i"
            dst="$i"
        fi

        if [[ ! $src =~ ^/ ]]; then
            src="$conf_dir/$src"
        fi

        src="$(realpath $src)"

        copy_file_and_dir_no_resolve_symlink "$src" "$dst"
    done

    debug "Building initrd image: ./image"

    local kernel_version="$(uname -r)"
    mkosi -f \
      --extra-tree="/usr/lib/modules/${kernel_version}:/usr/lib/modules/${kernel_version}" \
      build
    if [ $? -ne 0 ]; then
        error "Error: failed to build initrd image with mkosi"
        exit 1
    fi

    debug "Copying kernel: ./image.vmlinuz"

    if [ -s "/boot/vmlinuz-${kernel_version}" ]; then
        cp -f "/boot/vmlinuz-${kernel_version}" ./image.vmlinuz
        return 0
    fi

    error "Error: can't find the currently active kernel from /boot/"
    exit 1
}

start() {
    if [[ -f ./image && -f ./image.vmlinuz ]]; then
        systemd-run --user -d -u shelter.service -p StandardInput=null -G \
          /usr/bin/qemu-system-x86_64 \
            -accel kvm -m 4g --nographic \
            -kernel ./image.vmlinuz -initrd ./image \
            -append "console=ttyS0" \
            -device vhost-vsock-pci,guest-cid=21
    else
        error "The files ./image or ./image.vmlinuz is missing. You may need to run 'shelter build' first."
        exit 1
    fi
}

is-active() {
    systemctl --user -q is-active shelter.service
}

run() {
    start 1>&- 2>&-

    debug "The guest vm is booting"

    local wait_seconds=20
    debug "Now waiting ${wait_seconds} seconds for the guest to launch ..."

    local is_ready=0

    for ((i=${wait_seconds}; i>0; i--))
    do
        if ! is-active; then
            error "Failed to run shelter guest"
            return 1
        fi

        if socat /dev/null vsock-connect:21:4321 1>&- 2>&-; then
            # The guest is ready
            is_ready=1
            break
        fi

        sleep 1
    done

    if [[ $is_ready -ne 1 ]]; then
        error "Failed to run shelter guest"
        stop
        return 1
    fi

    if [[ $1 == "--" ]]; then
        shift
    fi

    debug "Run command in guest: '$@'"
    exec $@

    stop
}

status() {
    if is-active; then
        systemctl --user status shelter.service
        return 0
    fi

    echo "Shelter isn't running"
}

stop() {
    if ! is-active; then
        exit 0;
    fi

    debug "Send poweroff event to the guest vm"
    echo "/usr/bin/poweroff" | socat - vsock-connect:21:4321

    local wait_seconds=20
    debug "Now waiting ${wait_seconds} seconds for the guest vm to exit ..."

    for ((i=${wait_seconds}; i>0; i--))
    do
        if ! is-active; then
            debug "Shelter has been smoothly stopped"
            return 0
        fi
        sleep 1
    done

    systemctl --user stop shelter.service
    error "Shelter has been forcibly shut down"
}

exec() {
    if [[ $1 == "--" ]]; then
        shift
    fi

    echo "$@" | socat - vsock-connect:21:4321
}

clean() {
    mkosi clean
    rm -rf ./.cache
}

main() {
    # Check if a subcommand or help option is provided
    if [ $# -lt 1 ]; then
        show_help
        exit 1
    fi

    # Check for --help or -h options
    for arg in "$@"; do
        case $arg in
            -h|--help)
                show_help
                exit 0
                ;;
            --)
                break
                ;;
        esac
    done

    # Get subcommand
    subcommand=$1
    shift

    case $subcommand in
        start)
            start
            ;;
        stop)
            stop
            ;;
        build)
            build "$@"
            ;;
        status)
            status
            ;;
        run)
            run "$@"
            ;;
        exec)
            exec "$@"
            ;;
        clean)
            clean
            ;;
        help)
            show_help
            ;;
        *)
            echo "Unrecognized subcommand: $subcommand"
            exit 1
            ;;
    esac
}

trap_handler() {
    trap - SIGINT EXIT ERR

    local line_no="$1"
    local err=$2

    debug "Cleaning up ..."

    if [ $err -ne 0 ] && [ "$line_no" != "1" ]; then
        error "Error occurred on line $line_no, exit code: $err"
    fi

    debug "Exiting"

    exit $err
}

trap 'trap_handler $LINENO $?' SIGINT EXIT ERR

main "$@"