#!/usr/bin/env bash
conf="build.conf"
dest=".cache"

# Function: Display help information
show_help() {
    cat <<EOF
Usage: shelter {subcommand}
Available SubCommands:
    build   Build the shelter
    start   Start the shelter
    stop    Stop the shelter
    exec    exec a shell commad in shelter
    status  Query the status of shelter
    clean   Remove output image and cache

Options:
    -h, --help  Show this help message and exit
EOF
}

add_dir() {
    local dir_path=$1
    if [ ! -d ${dest}$dir_path ]; then
        mkdir -p ${dest}${dir_path}
    fi
}

# Function to copy file
copy_file() {
    local file_path=$(realpath -s $1)

    # Check if the file exists
    if [ ! -e "$file_path" ]; then
        echo "Error: $file_path is not a valid file path"
        exit 1
    fi

    # Check if the file already copied
    if [ -e "${dest}${file_path}" ]; then
        return
    fi

    # Check if file is symbolic link
    if [ -L "$file_path" ]; then
        local target_file_path=$(realpath $1)
        copy_file $target_file_path
        add_dir $(dirname $file_path)
        ln -sr ${dest}${target_file_path} ${dest}${file_path}
        return
    fi

    # Check if file is regular
    if [ -f "$file_path" ]; then
        add_dir $(dirname $file_path)
        cp ${file_path} ${dest}${file_path}
        return
    fi
    
    echo "$file_path isn't sysmlink or regular file"
    exit 1
}

# Function to copy shared library
copy_sodeps() {
    local binary_path=$1 

    # Check if the file exists
    if [ ! -f "$binary_path" ]; then
        echo "Error: $binary_path is not a valid file path"
        exit 1
    fi

    # Use ldd to get dependencies
    local dependencies
    dependencies=$(ldd "$binary_path" 2>/dev/null)

    if [ $? -ne 0 ]; then
        echo "Warn: $binary_path is not a dynamic binary"
        return 0
    fi

    # Parse ldd output and extract and copy dependency paths
    echo "$dependencies" | while read -r line; do
        local lib_path
        lib_path=$(echo "$line" | awk -F '=>' '{print $2}' | awk '{print $1}')
        if [ -n "$lib_path" ] && [ -e "$lib_path" ]; then
            copy_file "$lib_path"
        fi
    done
}

build() {
    local binaries=()
    local files=()

    echo "[-] Gather files to be copied to initrd"

    if [ ! -f $conf ]; then
        echo "Error: build.conf didn't exist"
        exit 0
    fi
    
    # Read options from the configuration file
    while IFS= read -r line || [ -n "$line" ]; do
        # Trim leading and trailing whitespace
        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        # Check line content and extract values
        if [[ $line == binary=* ]]; then
            # Remove binary= and parentheses
            line=$(echo "$line" | sed 's/^binary=//;s/[()]//g')
            # Split into an array and add to binaries array
            IFS=' ' read -r -a binary_array <<< "$line"
            binaries+=("${binary_array[@]}")
        elif [[ $line == file=* ]]; then
            # Remove file= and parentheses
            line=$(echo "$line" | sed 's/^file=//;s/[()]//g')
            # Split into an array and add to files array
            IFS=' ' read -r -a file_array <<< "$line"
            files+=("${file_array[@]}")
        fi
    done < "$conf"

    if [ ! -d $dest ]; then
        mkdir $dest
    fi

    for i in "${binaries[@]}"; do
        copy_sodeps $i
        copy_file $i
    done

    for i in "${files[@]}"; do
        copy_file $i
    done

    echo "[-] Build initrd image: ./image"

    mkosi -f --extra-tree="/usr/lib/modules/$(uname -r):/usr/lib/modules/$(uname -r)" build

    echo "[-] Copy kernel: ./image.vmlinuz"
    local kernel_version="$(uname -r)"
    for kernel_image in /boot/vmlinu*; do
        image_version=$(file -bL "$kernel_image" | grep -o 'version [^ ]*' | cut -d ' ' -f 2)
        if [[ "$image_version" == "$kernel_version" ]]; then
            cp $kernel_image ./image.vmlinuz
            return 0
        fi
    done

    echo "Error: can't find the currently active kernel from /boot/"
    exit 1
}

start() {
    if [[ -f ./image && -f ./image.vmlinuz ]]; then
        systemd-run \
        --user -d -u shelter.service -p StandardInput=null -G \
        /usr/bin/qemu-system-x86_64 -accel kvm -m 1g -kernel ./image.vmlinuz -initrd ./image --device vhost-vsock-pci,guest-cid=21 --append "console=ttyS0" --nographic
    fi
}

is-active() {
    systemctl --user -q is-active shelter.service
}

status() {
    if is-active; then
        systemctl --user status shelter.service
        return 0
    fi
    echo "Shelter isn't running"
}

stop() {
    if is-active; then
        echo "/usr/bin/poweroff" | socat - vsock-connect:21:4321
    fi
    
    for ((i=20; i>0; i--))
    do
        is-active
        if [ $? -ne 0 ]; then
            echo "Shelter has been smoothly shut down"
            return 0  
        fi
        sleep 1
    done
    systemctl --user stop shelter.service
    echo "Shelter has been forcibly shut down"
}

exec() {
    echo "$@" | socat - vsock-connect:21:4321
}

clean() {
    mkosi clean
    rm -r ./.cache
}

# Check if a subcommand or help option is provided
if [ $# -lt 1 ]; then
    show_help
    exit 1
fi

# Check for --help or -h options
for arg in "$@"; do
    case $arg in
        -h|--help)
            show_help
            exit 0
            ;;
    esac
done

# Get subcommand
subcommand=$1
shift

case $subcommand in
    start)
        start
        ;;
    stop)
        stop
        ;;
    build)
        build
        ;;
    status)
        status
        ;;
    exec)
        exec "$@"
        ;;
    clean)
        clean
        ;;
    help)
        show_help
        ;;
    *)
        echo "Unknown Subcommand: $subcommand"
        exit 1
        ;;
esac