#!/usr/bin/env bash

. `dirname $0`/logger.sh

conf="build.conf"
dest=".cache"

# Function: Display help information
show_help() {
    cat <<EOF
Usage: shelter {subcommand}
Available SubCommands:
    build   Build the shelter
    start   Start the shelter
    stop    Stop the shelter
    exec    exec a shell commad in shelter
    status  Query the status of shelter
    clean   Remove output image and cache

Options:
    -h, --help  Show this help message and exit
EOF
}

add_dir() {
    local dir_path=$1
    if [ ! -d ${dest}$dir_path ]; then
        mkdir -p ${dest}${dir_path}
    fi
}

# Function to copy file
copy_file() {
    local file_path=$(realpath -s $1)

    # Check if the file exists
    if [ ! -e "$file_path" ]; then
        error "Error: $file_path is not a valid file path"
        exit 1
    fi

    # Check if the file already copied
    if [ -e "${dest}${file_path}" ] && ! diff -q "${file_path}" "${dest}${file_path}" >/dev/null ; then
        warn "Warn: target file $file_path file already copied into $dest but different, will be overwrited"
    fi

    # Check if file is symbolic link
    if [ -L "$file_path" ]; then
        local target_file_path=$(realpath $1)
        copy_file $target_file_path
        add_dir $(dirname $file_path)
        rsync -a --links ${file_path} ${dest}${file_path}
        return
    fi

    # Check if file is regular
    if [ -f "$file_path" ]; then
        add_dir $(dirname $file_path)
        cp -a ${file_path} ${dest}${file_path}
        return
    fi

    warn "$file_path isn't sysmlink or regular file"
    exit 1
}

# Function to copy shared library
copy_sodeps() {
    local binary_path=$1

    # Check if the file exists
    if [ ! -f "$binary_path" ]; then
        error "Error: $binary_path is not a valid file path"
        exit 1
    fi

    # Use ldd to get dependencies
    local dependencies
    dependencies=$(ldd "$binary_path" 2>/dev/null)

    if [ $? -ne 0 ]; then
        warn "Warn: $binary_path is not a dynamic binary"
        return 0
    fi

    # Parse ldd output and extract and copy dependency paths
    echo "$dependencies" | while read -r line; do
        # Check if the line not contains '=>'
        if ! echo "$line" | grep -q '=>'; then
            # Extract the path, ensuring it starts with /
            local lib_path
            lib_path=$(echo "$line" | awk '{print $1}' | grep '^/')
            if [ -n "$lib_path" ]; then
                copy_file "$lib_path"
                continue
            fi
        else
            local lib_path
            lib_path=$(echo "$line" | awk -F '=>' '{print $2}' | awk '{print $1}')
            if [ -n "$lib_path" ] && [ -e "$lib_path" ]; then
                copy_file "$lib_path"
            fi
        fi
    done
}

build() {
    local binaries=()
    local files=()

    debug "Gather files to be copied to initrd and copy into $dest"
    rm -rf $dest

    if [ ! -f $conf ]; then
        error "Error: build.conf didn't exist"
        exit 0
    fi

    # Read options from the configuration file
    while IFS= read -r line || [ -n "$line" ]; do
        # Trim leading and trailing whitespace
        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        # Check line content and extract values
        if [[ $line == binary=* ]]; then
            # Remove binary= and parentheses
            line=$(echo "$line" | sed 's/^binary=//;s/[()]//g')
            # Split into an array and add to binaries array
            IFS=' ' read -r -a binary_array <<< "$line"
            binaries+=("${binary_array[@]}")
        elif [[ $line == file=* ]]; then
            # Remove file= and parentheses
            line=$(echo "$line" | sed 's/^file=//;s/[()]//g')
            # Split into an array and add to files array
            IFS=' ' read -r -a file_array <<< "$line"
            files+=("${file_array[@]}")
        fi
    done < "$conf"

    if [ ! -d $dest ]; then
        mkdir $dest
    fi

    for i in "${binaries[@]}"; do
        copy_sodeps $i
        copy_file $i
    done

    for i in "${files[@]}"; do
        copy_file $i
    done

    debug "Build initrd image: ./image"

    if ! mkosi -f --extra-tree="/usr/lib/modules/$(uname -r):/usr/lib/modules/$(uname -r)" build ; then
        error "Error: failed to build initrd image with mkosi"
        exit 1
    fi

    debug "Copy kernel: ./image.vmlinuz"
    local kernel_version="$(uname -r)"
    for kernel_image in /boot/vmlinu*; do
        image_version=$(file -bL "$kernel_image" | grep -o 'version [^ ]*' | cut -d ' ' -f 2)
        if [[ "$image_version" == "$kernel_version" ]]; then
            cp $kernel_image ./image.vmlinuz
            return 0
        fi
    done

    error "Error: can't find the currently active kernel from /boot/"
    exit 1
}

start() {
    if [[ -f ./image && -f ./image.vmlinuz ]]; then
        systemd-run \
        --user -d -u shelter.service -p StandardInput=null -G \
        /usr/bin/qemu-system-x86_64 -accel kvm -m 4g -kernel ./image.vmlinuz -initrd ./image --device vhost-vsock-pci,guest-cid=21 --append "console=ttyS0" --nographic
    else
        error "The files ./image or ./image.vmlinuz is missing. You may need to run 'shelter build' first."
        exit 1
    fi
}

is-active() {
    systemctl --user -q is-active shelter.service
}


run() {
    start 1>&- 2>&-

    debug "The guest vm is booting"

    wait_seconds=20
    debug "Now waiting ${wait_seconds} seconds for the guest vm to ready ..."

    is_ready=0

    for ((i=${wait_seconds}; i>0; i--))
    do
        if ! is-active; then
            error "Failed to run shelter guest vm"
            return 1
        fi

        if socat /dev/null vsock-connect:21:4321 1>&- 2>&-; then
            # The vm is ready
            is_ready=1
            break
        fi

        sleep 1
    done

    if [[ ! $is_ready -eq 1 ]]; then
        error "Failed to run shelter guest vm"
        stop
        return 1
    fi

    if [[ $1 == "--" ]]; then
        shift
    fi

    debug "Run command in guest: '$@'"
    exec $@

    stop
}


status() {
    if is-active; then
        systemctl --user status shelter.service
        return 0
    fi
    echo "Shelter isn't running"
}

stop() {
    if ! is-active; then
        exit 0;
    fi

    debug "Send poweroff event to the guest vm"
    echo "/usr/bin/poweroff" | socat - vsock-connect:21:4321

    wait_seconds=20
    debug "Now waiting ${wait_seconds} seconds for the guest vm to exit ..."

    for ((i=${wait_seconds}; i>0; i--))
    do
        is-active
        if [ $? -ne 0 ]; then
            debug "Shelter has been smoothly shut down"
            return 0
        fi
        sleep 1
    done
    systemctl --user stop shelter.service
    error "Shelter has been forcibly shut down"
}

exec() {
    if [[ $1 == "--" ]]; then
        shift
    fi

    echo "$@" | socat - vsock-connect:21:4321
}

clean() {
    mkosi clean
    rm -r ./.cache
}

# Check if a subcommand or help option is provided
if [ $# -lt 1 ]; then
    show_help
    exit 1
fi

# Check for --help or -h options
for arg in "$@"; do
    case $arg in
        -h|--help)
            show_help
            exit 0
            ;;
        --)
            break
            ;;
    esac
done

# Get subcommand
subcommand=$1
shift

case $subcommand in
    start)
        start
        ;;
    stop)
        stop
        ;;
    build)
        build
        ;;
    status)
        status
        ;;
    run)
        run "$@"
        ;;
    exec)
        exec "$@"
        ;;
    clean)
        clean
        ;;
    help)
        show_help
        ;;
    *)
        echo "Unknown Subcommand: $subcommand"
        exit 1
        ;;
esac